===================
Object-oriented C++
===================

[default_span] math

[math]
    \int \limits_a^b
        \frac{1}{\sqrt{2\pi}\sigma^2}
        \exp \left[
            -\frac{1}{2 \sigma^2} x^2 
        \right] dx
     

Constructors and destructors
============================

Construction order
------------------

While constructing or restructing, one can safely access base class members only.

**Construction order**:
  
1. Virtual bases left-to-right depth-first in declaration order.
2. Bases left-to-right in declaration order.
3. Members in declaration order.
    
**Destruction order**: reverse order of construction for local vars.

- And for arrays;
- And for members.

Constructors
------------

- Within constructor, you **can't call other constructor.**
  
  - `Foo(x, y)` creates temporary variable.
  - Default parameters might help.
  - Move functionality to `init()` function
  - Placement new DOES NOT work and IS EVIL since ctor does many little magical
    things.
    
- **Default constructor**
  
  Default constructor is ctor that can be called with no arguments:
  
  - Called by default;
  - Called on array creation.
  
- **Initializer lists**
  
  - Improved performance (inplace construction with no cctor or asop involved).
  - Improved even for built-in types.
  
- **Return-by-value**
    
  - Return-by-value doesn't impose extra copy on modern compilers
  
  - Number of copies and constructors invoked are not stdized.
    GCC optimizes, MSVC constructs result, then copy-constructs value.
    
Destructors
-----------
  
- One **MUST NOT call dtor explicitly**
    
  If you want to, use `{}`.
  
- One **MUST call dtor** explicitly **on placement new**.

Autogenerated members
=====================

[todo] table

[code]
    =============== ======================= =============== =================== ==================================
    Entity          Default constructor     Destructor      Copy constructor    Assign operator
    =============== =======================+=============== =================== ==================================
    When generated  When there are no other|                 When not written
                    constructors           |
    --------------- -----------------------+---------------+------------------------------------------------------
    Parameters                      None                   | `const T&` if possible 
                                                           | (member and base cctors/asops get const parameter).
                                                           | Else `T&`.
    --------------- -----------------------+---------------+------------------------------------------------------
    Behaviour       Call bases' default    |        Call members' dtors/cctors/asops
                    cctors                 | 
    --------------- -----------------------+----------------------------------------------------------------------
    
Base can make derived class write ctor, cctor, and asop in order to instantiate.
Nothing in C++ can make child write its own destructor: default will always be 
good.

Virtuality
==========

Constructor and destructor
--------------------------

- **Virtual ctor**
  
  No support in C++, use `virtual clone();` or `virtual create();`.

- **Virtual dtor**
  
  - Needed when someone will delete via base ptr.
  - Rationale: make dtor virtual if class has virtual functions.
  
- **No virtual function calls in constructor or destructor**
    
  Because while construction is in process, object is of `Base` class yet, 
  not of `Derived`.
  
  If a called virtual function is pure virtual, you'll get an error, 
  else you'll just get unexpected behaviour.
  
  - To fix, use two-stage init with `init()` function
    and named constructor idiom (don't forget `auto_ptr` ownership on object 
    (to crash properly).
    
  - Other approach: move virtual constructor pieces into helper class, 
    and pass helper to a constructor.
    
Pure virtual
------------
  
- How to **seal a class**
  
  #. Comments and the docs.
  #. Private ctor.
  
- How to **seal a method**
  
  #. Comments and the docs.
  
- **Pure virtualness means "override is needed"** to instantiate.
  
  It doesn't meen "function has no body". For example, pure virtual **destructor 
  MUST have a body.**
    
Inheritance
===========

- Use explicit **`Base::f()` to call base function**
    
  Not a virtual call, not a virtual cost.
   
- **No C-style downcasts** on MI/VI. `dynamic_cast` only!
  
  See implementation.

Privacy
-------

- Derived class can hide members

  [c++]
      class D: public B
      {
      private:
          using B::f();
      };
  
- **`derived\*\* -> base\*\*`** conversion is not allowed (see const correctness).

- **Private inheritance is kinda composition**, except composition is better

- **Private virtuals** are valid
    
  They can be overloaded but still can't be called.

- Inheritance **access control** controls whether you can **convert** `Derived*` to
  `Base*`
      
Multiple inheritance
--------------------

Dreaded diamond:
    
  
[code]
        Base
        /  \
       /    \
      /      \
    Der1      Der2
      \      /
       \    /
        \  /
        Join

Base is included twice, ambiguous base member assignment.

Resolved via vitrual inheritance:

[code]
            Base
            /  \
           /    \
  virtual /      \ virtual
      Der1      Der2
          \      /
           \    /
            \  /
            Join
                    
**Virtual base constructors are invoked DIRECTLY** from most-derived constructor.

It should have all the parameters.
      

Pointers to (member) functions
==============================

- **Pointer to function**: `int (*)(char,float)`

- **Pointer to member function**: `int (Fred::*)(char,float)`

- (Non-static) member functions **need an object** to be called.
    
  You need to pass an object to use member function as a callback.
  Use functor objects.

- **Static** functions are the *same as plain* functions

- **Use typedefs**
  
  [c++]
      typedef  int (Fred::*FredMemFn)(char x, float y);  < please do this!
      FredMemFn p = &Fred::f;
      Fred fred;
      fred.*p;
      (&fred)->*p;
      
- You **can't convert func ptr** to `void*`
  
  Machine might be non-von-neumann. (LOLWHAT?)
  
- You **can't convert member func ptr** to `void*`
  
  Consider a pointer to a virtual member function.

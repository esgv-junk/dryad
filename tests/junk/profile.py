# -*- coding: utf-8 -*-

import cProfile

from dryad import markup

def render_page():
    page_source = u"""
==============
Поиск в ширину
==============

[default_span] math

Алгоритм
========

[remark]
    Пока будем рассматривать поиск в ширину, примем число за длину пути рёбер в нём. Соответственно, расстоянием между двумя вершинами будет длина такого пути между этими двумя вершинами, что число рёбер в минимально.

**Поиск в ширину** имеет следующие свойства.

- Получает на вход вершину `s`.
- Определяет множество вершин, куда можно добраться из вершины `s`:

  [math]
    X = \{x \mid \exists P: s \to x \}.

  В ненаправленном графе, это множество -- компонента связности вершины `s`.
- Разбивает множество `X` на "слои" по расстоянию: вершины, до которых расстояние
  0 (в этот слой входит только сама вершина `s`), вершины, расстояние до которых
  равно 1, и так далее.

  [image] thief.png

  [remark]
    Рёбра в графе не могут идти произвольным образом.

    - Рёбра (граф будем считать направленным) могут идти

      - вниз на один слой,
      - вверх,
      - внутри слоя;

      то есть, рёбра не могут идти вниз более, чем на один слой
      (иначе бы расстояние было посчитано неверно);

    - Кроме того, в каждую вершину любого слоя (кроме 0-го) входит как минимум
      одно ребро из предыдущего слоя.

**Алгоритм.**

[default_span] code

В процессе работы используется очередь `Q`, и одномерный массив `d`,
индексируемый вершинами (в нём хранятся расстояния).

[python]
    def breadth_first_search(Graph, s)
        d[s] = 0
        Q.enqueue(s)

        while not Q.empty():
            x = Q.dequeue()                 # на первой итерации будет
                                            # извлечена вершина s
            for (x, y) in Graph.edges:      # для всех рёбер, исходящих из вершины x
                if d[y] is None:
                    d[y] = d[x] + 1
                    Q.enqueue(y)

[remark] Общие признаки
    Приведённый выше код является в каком-то смысле общим, потому что в
    других алгоритмах обхода графа присутствуют похожие элементы:

    - Структура данных, которая запоминает
    - Структура данных, которая запоминает и не завбывает называется *злопамятной структурой данных*.
"""
    rendered_page =\
        markup.render(page_source, 'html')

cProfile.run('render_page()')
cProfile.run('render_page()')
